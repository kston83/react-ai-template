---
description: 
globs: 
alwaysApply: false
---
---
description: Common patterns and best practices
globs: 
alwaysApply: true
---
# 3. Common Patterns and Best Practices

This document outlines common coding patterns and best practices for this project.

## Component Patterns

### Controlled Components

Use controlled components for form elements whenever possible:

```tsx
function ControlledInput() {
  const [value, setValue] = React.useState('');
  
  return (
    <input 
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

### Component Composition

Prefer composition over complex conditional rendering:

```tsx
// Preferred
function UserProfile({ user, isEditable }) {
  return (
    <ProfileCard>
      <ProfileHeader user={user} />
      {isEditable ? <EditableProfileContent user={user} /> : <ProfileContent user={user} />}
      <ProfileFooter />
    </ProfileCard>
  );
}

// Instead of
function UserProfile({ user, isEditable }) {
  return (
    <div>
      <div className="header">
        {/* header content */}
      </div>
      <div className="content">
        {isEditable ? (
          // Editable content with many lines
        ) : (
          // Non-editable content with many lines
        )}
      </div>
      <div className="footer">
        {/* footer content */}
      </div>
    </div>
  );
}
```

### Loading and Error States

Handle loading and error states consistently:

```tsx
function DataComponent() {
  const { data, isLoading, error } = useData();
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  if (error) {
    return <ErrorMessage error={error} />;
  }
  
  if (!data) {
    return <EmptyState />;
  }
  
  return <DataDisplay data={data} />;
}
```

### Feature Flags

For features in development or A/B testing, use feature flags:

```tsx
function FeatureComponent() {
  const { isFeatureEnabled } = useFeatureFlags();
  
  return (
    <div>
      {isFeatureEnabled('new-ui') ? (
        <NewFeature />
      ) : (
        <ExistingFeature />
      )}
    </div>
  );
}
```

## Hook Patterns

### Data Fetching Pattern

Use a consistent pattern for data fetching with React Query:

```tsx
// src/features/users/hooks/use-user-data.ts
import { useQuery } from '@tanstack/react-query';
import { fetchUser } from '../api';

export function useUserData(userId: string) {
  return useQuery({
    queryKey: ['users', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}
```

### Mutation Pattern

Handle mutations with a consistent approach:

```tsx
// src/features/users/hooks/use-update-user.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { updateUser } from '../api';

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateUser,
    onSuccess: (data, variables) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['users', variables.id] });
      
      // Or update the cache directly
      queryClient.setQueryData(['users', variables.id], data);
    },
  });
}
```

### Local Storage Hook

For persisting state in localStorage:

```tsx
function useLocalStorage<T>(key: string, initialValue: T) {
  // State to store our value
  const [storedValue, setStoredValue] = React.useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }
    
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  // Return a wrapped version of useState's setter function
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function for same API as useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      
      setStoredValue(valueToStore);
      
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue] as const;
}
```

## Error Handling Patterns

### API Error Handling

Handle API errors consistently:

```tsx
async function fetchWithErrorHandling(url: string) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      // Handle HTTP errors
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        errorData.message || `HTTP error ${response.status}`
      );
    }
    
    return await response.json();
  } catch (error) {
    // Log the error
    console.error('API Error:', error);
    
    // Rethrow or transform
    throw error;
  }
}
```

### Error Boundaries

Use Error Boundaries for isolating component errors:

```tsx
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <p>Something went wrong:</p>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        // Reset the state of your app here
      }}
    >
      <YourComponent />
    </ErrorBoundary>
  );
}
```

## Form Handling Patterns

### React Hook Form with Zod

For forms with validation:

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

// Define schema
const formSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(8, { message: "Password must be at least 8 characters" }),
});

type FormValues = z.infer<typeof formSchema>;

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<FormValues>({
    resolver: zodResolver(formSchema),
  });
  
  const onSubmit = (data: FormValues) => {
    console.log(data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" {...register('email')} />
        {errors.email && <p>{errors.email.message}</p>}
      </div>
      
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" type="password" {...register('password')} />
        {errors.password && <p>{errors.password.message}</p>}
      </div>
      
      <button type="submit">Login</button>
    </form>
  );
}
```

## Performance Patterns

### Memoization

Use memoization for expensive calculations or to prevent unnecessary re-renders:

```tsx
function ExpensiveComponent({ data }) {
  // Memoize expensive calculation
  const processedData = React.useMemo(() => {
    return expensiveCalculation(data);
  }, [data]);
  
  // Memoize callback
  const handleClick = React.useCallback(() => {
    console.log('Clicked!', data.id);
  }, [data.id]);
  
  return (
    <div onClick={handleClick}>
      {processedData.map(item => (
        <Item key={item.id} data={item} />
      ))}
    </div>
  );
}

// Memoize component to prevent re-renders when props don't change
const MemoizedChild = React.memo(function Child({ data }) {
  return <div>{data.name}</div>;
});
```

### Code Splitting

Use dynamic imports for code splitting:

```tsx
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function MyComponent() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </React.Suspense>
  );
}
```

## Accessibility Patterns

### Keyboard Navigation

Ensure proper keyboard navigation:

```tsx
function AccessibleButton() {
  return (
    <button
      onClick={handleClick}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          handleClick();
        }
      }}
      tabIndex={0}
      aria-label="Descriptive label"
    >
      Click Me
    </button>
  );
}
```

### Screen Reader Support

Include proper ARIA attributes:

```tsx
function Dialog({ isOpen, onClose, title, children }) {
  return (
    <div
      role="dialog"
      aria-modal="true"
      aria-labelledby="dialog-title"
      aria-describedby="dialog-description"
    >
      <h2 id="dialog-title">{title}</h2>
      <div id="dialog-description">
        {children}
      </div>
      <button onClick={onClose} aria-label="Close dialog">
        Close
      </button>
    </div>
  );
}
```

## Testing Patterns

### Component Testing

Test components for rendering and interaction:

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  test('renders with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
  
  test('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### Hook Testing

Test custom hooks:

```tsx
import { renderHook, act } from '@testing-library/react-hooks';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  test('should increment counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
});
```