---
description: 
globs: 
alwaysApply: false
---
---
description: Testing patterns and guidelines
globs: 
alwaysApply: true
---
# 4. Testing Patterns and Guidelines

This document covers testing patterns and guidelines for this project.

## Testing Setup

This project uses:
- **Vitest**: For running tests
- **React Testing Library**: For testing React components
- **@testing-library/user-event**: For simulating user interactions
- **@testing-library/jest-dom**: For additional DOM matchers

## Test Organization

Tests should be co-located with the code they're testing:

```
src/
├── components/
│   └── Button/
│       ├── Button.tsx
│       └── Button.test.tsx
├── hooks/
│   ├── useCounter.ts
│   └── useCounter.test.ts
└── utils/
    ├── formatters.ts
    └── formatters.test.ts
```

## Component Testing

When testing components, focus on behavior rather than implementation details:

```tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Button } from './Button'

describe('Button', () => {
  it('calls onClick when clicked', async () => {
    const handleClick = vi.fn()
    render(<Button onClick={handleClick}>Click Me</Button>)
    
    await userEvent.click(screen.getByRole('button', { name: /click me/i }))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })
})
```

### Testing Best Practices for Components

1. **Use semantic queries**:
   - Prefer `getByRole` over `getByTestId`
   - Use `getByLabelText` for form elements
   - Resort to `getByText` when appropriate

2. **Test user interactions** using `userEvent` rather than `fireEvent` when possible.

3. **Mock context providers** when components rely on them:

```tsx
function renderWithProviders(ui, { providerProps, ...renderOptions } = {}) {
  return render(
    <ThemeProvider {...providerProps}>{ui}</ThemeProvider>,
    renderOptions
  )
}
```

## Hook Testing

Test custom hooks using the `renderHook` utility:

```tsx
import { renderHook, act } from '@testing-library/react'
import { useCounter } from './useCounter'

describe('useCounter', () => {
  it('should increment counter', () => {
    const { result } = renderHook(() => useCounter())
    
    act(() => {
      result.current.increment()
    })
    
    expect(result.current.count).toBe(1)
  })
})
```

### Hook Testing Best Practices

1. Always use `act` for state updates
2. Test all possible states and transitions
3. Provide mocked dependencies if the hook uses other hooks

## Utility Testing

Test utility functions with straightforward input/output assertions:

```tsx
import { formatCurrency } from './formatters'

describe('formatCurrency', () => {
  it('formats positive numbers correctly', () => {
    expect(formatCurrency(123.45)).toBe('$123.45')
  })
})
```

## Mocking

### Mocking API Calls

Use vitest's mocking capabilities:

```tsx
import { vi } from 'vitest'
import { fetchUserData } from './api'

vi.mock('./api', () => ({
  fetchUserData: vi.fn()
}))

describe('User component', () => {
  it('displays user data when loaded', async () => {
    fetchUserData.mockResolvedValueOnce({ name: 'John' })
    // Test component that uses fetchUserData
  })
})
```

### Mocking Time

For time-dependent tests:

```tsx
beforeEach(() => {
  vi.useFakeTimers()
})

afterEach(() => {
  vi.useRealTimers()
})

it('updates after timeout', () => {
  render(<TimedComponent />)
  vi.advanceTimersByTime(1000)
  // Assert changes after timeout
})
```

## Running Tests

Use the following npm scripts:

- `npm test`: Run all tests
- `npm run test:watch`: Run tests in watch mode
- `npm run test:coverage`: Run tests with coverage report

## Test Coverage

Aim for meaningful test coverage rather than arbitrary percentage targets:

1. All user-facing components should have tests for key interactions
2. Critical business logic should have extensive test coverage
3. Edge cases and error states should be tested
4. Focus on the quality of tests over quantity